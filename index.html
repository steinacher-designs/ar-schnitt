<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>WebAR Hausquerschnitt</title>
<script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image.prod.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
<style>
  html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
  a-scene { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
</style>
</head>
<body>

<a-scene mindar-image="imageTargetSrc: ./assets/hausschnitt.mind;" embedded vr-mode-ui="enabled: false">
  <a-camera position="0 0 0"></a-camera>

  <!-- AR-Inhalt -->
  <a-entity mindar-image-target="targetIndex: 0">
    <!-- Modell startet unsichtbar (scale 0). Wir nutzen Events zum sanften Ein-/Ausblenden
         und die keep-level Komponente, damit das Modell X/Z-rotation gesperrt bleibt. -->
    <!-- ======= schnittModel (3D Section) ======= -->
    <!--
         Configure visibility/orientation here:
         - To change the fixed rotation that the model will keep, edit the lock-rotation attribute below.
           Examples:
             lock-rotation="rotation: 0 0 0"   -> front faces camera
             lock-rotation="rotation: 0 90 0"  -> rotate 90 degrees around Y
             lock-rotation="rotation: 0 180 0" -> flipped 180 degrees

         - The model is positioned relative to the detected image by the anchor-to-target offset.
           Change offset X/Y/Z to move it left/right/up/forward, e.g. offset: -0.4 0 -0.05

         - If the model is invisible, first try:
             1) set scale to 1 1 1
             2) change lock-rotation to 0 0 0
             3) move Z offset closer (e.g. -0.05)

         - Quick runtime commands (browser console):
             document.getElementById('schnittModel').setAttribute('rotation','0 0 0')
             document.getElementById('schnittModel').setAttribute('lock-rotation','rotation: 0 0 0')
             document.getElementById('schnittModel').emit('showModel')
    -->
    <a-gltf-model id="schnittModel" class="clickable"
      src="./assets/schnitt.glb"
      position="0 0 0"
      rotation="0 180 0"
      scale="0 0 0"
      keep-level
      <!-- lock-rotation: change these numbers to change the model's fixed orientation -->
      lock-rotation="rotation: 0 180 0"
      <!-- anchor-to-target offset: X Y Z (relative to the detected image). adjust to position model over picture -->
  anchor-to-target="offset: -0.4 0 -0.1; lerp: 0.12; freezeOnFound: true"
      animation__show="property: scale; from: 0 0 0; to: 1 1 1; dur: 300; startEvents: showModel"
      animation__hide="property: scale; to: 0 0 0; dur: 200; startEvents: hideModel">
    </a-gltf-model>
    <!-- ======= end schnittModel ======= -->
  </a-entity>
</a-scene>

<!-- Interior overlay (hidden until schnittModel is clicked) -->
<div id="interiorContainer" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button id="closeInterior" style="position:absolute;z-index:10000;top:12px;left:12px;padding:8px 12px;">Zurück</button>
  <a-scene id="interiorScene" embedded vr-mode-ui="enabled: false" style="width:100%;height:100%;">
    <a-assets>
      <a-asset-item id="ganzModel" src="./assets/ganz.glb"></a-asset-item>
    </a-assets>

    <!-- Player rig: camera with WASD and look controls. Default position inside house; adjust as needed -->
    <a-entity id="player" position="0 1.6 0">
      <a-camera wasd-controls="acceleration:50" look-controls></a-camera>
    </a-entity>

    <!-- Full house model -->
    <a-entity id="ganzEntity" gltf-model="#ganzModel" position="0 0 0" rotation="0 180 0"></a-entity>
  </a-scene>
</div>

<script>
  // Keep model level: sperrt X/Z-Rotation
  // Anchor-to-target: smoothly set this entity's world transform to the detected target + offset.
  // This reduces jitter by interpolating position and rotation.
  AFRAME.registerComponent('anchor-to-target', {
    schema: {
      target: { type: 'selector', default: undefined },
      offset: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
      lerp: { type: 'number', default: 0.12 },
      freezeOnFound: { type: 'boolean', default: false }
    },
    init: function () {
      this.targetEl = this.data.target || document.querySelector('[mindar-image-target]');
      this.targetObj = this.targetEl ? this.targetEl.object3D : null;
      this.desiredPos = new AFRAME.THREE.Vector3();
      this.desiredQuat = new AFRAME.THREE.Quaternion();
      this.tmpParentQuat = new AFRAME.THREE.Quaternion();
      this.tmpLocalPos = new AFRAME.THREE.Vector3();
      this.frozen = false;
      this.frozenLocalPos = new AFRAME.THREE.Vector3();

      // If requested, listen for targetFound/targetLost on the target element to freeze position
      if (this.data.freezeOnFound && this.targetEl) {
        this._onFound = () => {
          // compute desired world pos + offset immediately and store as frozen local pos
          const desiredWorld = new AFRAME.THREE.Vector3();
          this.targetObj.getWorldPosition(desiredWorld);
          const targetQuat = new AFRAME.THREE.Quaternion();
          this.targetObj.getWorldQuaternion(targetQuat);
          const off = new AFRAME.THREE.Vector3(this.data.offset.x, this.data.offset.y, this.data.offset.z);
          off.applyQuaternion(targetQuat);
          desiredWorld.add(off);
          // convert to parent-local
          const parent = this.el.object3D.parent;
          if (parent) {
            this.frozenLocalPos.copy(desiredWorld);
            parent.worldToLocal(this.frozenLocalPos);
            this.frozen = true;
          }
        };
        this._onLost = () => { this.frozen = false; };
        this.targetEl.addEventListener('targetFound', this._onFound);
        this.targetEl.addEventListener('targetLost', this._onLost);
      }
    },
    tick: function () {
      if (!this.targetObj) return;
      // If frozen (we captured pose on targetFound), keep fixed local position
      if (this.frozen) {
        const elObjF = this.el.object3D;
        elObjF.position.copy(this.frozenLocalPos);
        return;
      }
      // Get target world position
      this.targetObj.getWorldPosition(this.desiredPos);

      // Apply offset in target's local space by rotating the offset vector by target quaternion
      const targetQuat = new AFRAME.THREE.Quaternion();
      this.targetObj.getWorldQuaternion(targetQuat);
      const off = new AFRAME.THREE.Vector3(this.data.offset.x, this.data.offset.y, this.data.offset.z);
      off.applyQuaternion(targetQuat);
      this.desiredPos.add(off);

      // Convert desired world position into local coordinates of this entity's parent
      const elObj = this.el.object3D;
      const parent = elObj.parent;
      if (!parent) return;

      this.tmpLocalPos.copy(this.desiredPos);
      parent.worldToLocal(this.tmpLocalPos);

      // Smoothly interpolate current local position toward target local position
      elObj.position.lerp(this.tmpLocalPos, this.data.lerp);
      // Note: we don't override rotation here to avoid conflicts; keep-level still enforces upright orientation
    }
  });

  AFRAME.registerComponent('keep-level', {
    tick: function () {
      const el = this.el;
      const rot = el.getAttribute('rotation');
      if (!rot) return;
      // Nur Y-Rotation beibehalten
      if (Math.abs(rot.x) > 0.0001 || Math.abs(rot.z) > 0.0001) {
        el.setAttribute('rotation', { x: 0, y: rot.y, z: 0 });
      }
    }
  });

  // Lock rotation: enforce a fixed rotation (in degrees) every frame so the model never rotates
  AFRAME.registerComponent('lock-rotation', {
    schema: {
      rotation: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }
    },
    init: function () {
      // store fixed rotation in degrees
      const r = this.data.rotation;
      this.fixed = { x: r.x, y: r.y, z: r.z };
      // apply immediately
      this.el.setAttribute('rotation', this.fixed);
    },
    tick: function () {
      // enforce rotation every frame (prevents tracker-induced rotation)
      this.el.setAttribute('rotation', this.fixed);
    }
  });

  const target = document.querySelector("[mindar-image-target]");
  const model = document.getElementById('schnittModel');

  target.addEventListener("targetFound", () => {
    console.log("Bild erkannt – Tracking läuft weiter!");
    // Sanft einblenden
    model.emit('showModel');
  });
  target.addEventListener("targetLost", () => {
    console.log("Bild nicht mehr erkannt");
    // Sanft ausblenden
    model.emit('hideModel');
  });

  // Touch-Start für iOS
  document.body.addEventListener("click", () => {
    const scene = document.querySelector("a-scene");
    scene.components["mindar-image"].start(); // Kamera starten
  }, {once: true});

  // Öffne das Innenraum-Erlebnis, wenn das Schnitt-Modell angetippt wird
  model.addEventListener('click', openInterior);

  function openInterior() {
    const arScene = document.querySelector('a-scene[mindar-image]');
    // Stoppe MindAR (Kamera) und verstecke die AR-Szene
    if (arScene && arScene.components && arScene.components['mindar-image']) {
      try { arScene.components['mindar-image'].stop(); } catch(e) { console.warn(e); }
    }
    if (arScene) arScene.style.display = 'none';

    // Zeige das Innenraum-Overlay
    const container = document.getElementById('interiorContainer');
    container.style.display = 'block';

    // Optional: setze die Player-Startposition ins Haus (anpassen falls nötig)
    const player = document.getElementById('player');
    if (player) {
      player.setAttribute('position', '0 1.6 0');
    }
  }

  // Schließe das Innenraum-Erlebnis und starte AR wieder
  const closeBtn = document.getElementById('closeInterior');
  closeBtn.addEventListener('click', () => {
    const container = document.getElementById('interiorContainer');
    container.style.display = 'none';
    const arScene = document.querySelector('a-scene[mindar-image]');
    if (arScene) arScene.style.display = 'block';
    if (arScene && arScene.components && arScene.components['mindar-image']) {
      try { arScene.components['mindar-image'].start(); } catch(e) { console.warn(e); }
    }
  });

  // Wenn das Hausmodell geladen ist, positioniere den Player automatisch in der Mitte (leicht erhöht)
  const ganzEntity = document.getElementById('ganzEntity');
  if (ganzEntity) {
    ganzEntity.addEventListener('model-loaded', () => {
      try {
        const obj = ganzEntity.getObject3D('mesh');
        if (obj) {
          const box = new AFRAME.THREE.Box3().setFromObject(obj);
          const center = box.getCenter(new AFRAME.THREE.Vector3());
          const player = document.getElementById('player');
          if (player) {
            // setze Spieler leicht über Boden (center.y + 1.6)
            player.setAttribute('position', `${center.x} ${center.y + 1.6} ${center.z}`);
          }
        }
      } catch (e) { console.warn('Positioning interior player failed', e); }
    });
  }
</script>

</body>
</html>
